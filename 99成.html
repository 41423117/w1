<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è›‡è¡Œæ©Ÿå™¨äººæ¨¡æ“¬</title>
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/brython@3/brython_stdlib.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        .simulation-area {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }
        .controls {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2980b9;
        }
        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .keyboard-hints {
            background: #e8f4fc;
            padding: 10px 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .description {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }
        .description h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .description p {
            margin-bottom: 10px;
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #7f8c8d;
        }
        footer a {
            color: #3498db;
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            .control-buttons {
                flex-direction: column;
            }
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body onload="brython()">
    <div class="container">
        <header>
            <h1>ğŸ è›‡è¡Œæ©Ÿå™¨äººæ¨¡æ“¬</h1>
            <p>æ©Ÿå™¨äººå¾ (0,0) é–‹å§‹ï¼Œä»¥è›‡è¡Œæ–¹å¼èµ°å®Œ 10x10 ç¶²æ ¼çš„æ‰€æœ‰æ ¼å­</p>
        </header>
        
        <main>
            <div class="simulation-area">
                <div id="brython_div1"></div>
            </div>
            
            <div class="controls">
                <h3>æ§åˆ¶æ–¹å¼</h3>
                <div class="control-buttons">
                    <button id="move_button" class="btn btn-primary">Move Forward (J)</button>
                    <button id="turn_button" class="btn btn-secondary">Turn Left (I)</button>
                    <button id="reset_button" class="btn btn-danger">é‡ç½®æ¨¡æ“¬</button>
                </div>
                <div class="keyboard-hints">
                    <p><strong>éµç›¤æ§åˆ¶ï¼š</strong> J = å‰é€², I = å·¦è½‰</p>
                </div>
            </div>
            
            <div class="description">
                <h3>é—œæ–¼æ­¤å°ˆæ¡ˆ</h3>
                <p>æ­¤æ¨¡æ“¬ä½¿ç”¨ Brython (Browser Python) åœ¨ç¶²é ä¸­å¯¦ç¾æ©Ÿå™¨äººå‹•ç•«ã€‚</p>
                <p>æ©Ÿå™¨äººæœƒè‡ªå‹•å¾å·¦ä¸‹è§’ (0,0) é–‹å§‹ï¼Œä»¥è›‡è¡Œæ–¹å¼éæ­·æ•´å€‹ 10x10 çš„ç¶²æ ¼ï¼Œä¸¦åœ¨èµ°éçš„è·¯å¾‘ä¸Šç•™ä¸‹ç´…è‰²è»Œè·¡ã€‚</p>
            </div>
        </main>
        
        <footer>
            <p>Â© 2025 è›‡è¡Œæ©Ÿå™¨äººæ¨¡æ“¬å°ˆæ¡ˆ | ä½¿ç”¨ <a href="https://brython.info/" target="_blank">Brython</a> é–‹ç™¼</p>
        </footer>
    </div>

    <script type="text/python">
from browser import document, html, timer, bind

CELL_SIZE = 40
WALL_THICKNESS = 6
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"

class World:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.layers = self._create_layers()
        self._init_html()
        self._draw_grid()
        self._draw_walls()
    
    def _create_layers(self):
        return {
            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
        }

    def _init_html(self):
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px",
            "border": "2px solid #333",
            "border-radius": "5px"
        })
        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas
        
        document["brython_div1"].clear()
        document["brython_div1"] <= container
    
    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        img = html.IMG()
        img.src = src
        def onload(evt):
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)
    
    def _draw_walls(self):
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            # North wall
            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1,
                             CELL_SIZE, WALL_THICKNESS, offset_y=0)
            # South wall
            self._draw_image(ctx, IMG_PATH + "north.png", x, 0,
                             CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)
        for y in range(self.height):
            # West wall
            self._draw_image(ctx, IMG_PATH + "east.png", 0, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=0)
            # East wall
            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

class AnimatedRobot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1
        self.y = y - 1
        self.facing = "E"
        self.facing_order = ["E", "N", "W", "S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []
        self.running = False
        self._draw_robot()
    
    def _robot_image(self):
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(),
                               self.x, self.y, CELL_SIZE, CELL_SIZE)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"
        ctx.lineWidth = 2
        ctx.beginPath()
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        def action(next_done):
            def step():
                nonlocal steps
                if steps == 0:
                    next_done()
                    return
                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                if self.facing == "E":
                    dx = 1
                elif self.facing == "W":
                    dx = -1
                elif self.facing == "N":
                    dy = 1
                elif self.facing == "S":
                    dy = -1
                next_x = self.x + dx
                next_y = self.y + dy
    
                # Boundary check
                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, 200)
                else:
                    print("ğŸš¨ å·²ç¶“æ’ç‰†ï¼Œåœæ­¢ç§»å‹•ï¼")
                    next_done()
            step()
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot()
            timer.set_timeout(done, 300)
        self.queue.append(action)
        self._run_queue()
    
    def turn_right(self):
        # å³è½‰ç­‰æ–¼å·¦è½‰ä¸‰æ¬¡
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 3) % 4]  # +3 ç­‰æ–¼ -1 (å·¦è½‰ä¸‰æ¬¡)
            self._draw_robot()
            timer.set_timeout(done, 300)
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        if self.running or not self.queue:
            return
        self.running = True
        action = self.queue.pop(0)
        action(lambda: self._done())

    def _done(self):
        self.running = False
        self._run_queue()
    
    def reset(self):
        self.queue = []
        self.running = False
        self.x = 0
        self.y = 0
        self.facing = "E"
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.trace_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self._draw_robot()

# Create world and robot
w = World(10, 10)
r = AnimatedRobot(w, 1, 1)

# Bind keyboard events
@bind(document, "keydown")
def keydown(evt):
    if evt.key == "j" or evt.key == "J":
        r.move(1)
    elif evt.key == "i" or evt.key == "I":
        r.turn_left()

# Bind button events
@bind(document["move_button"], "click")
def move_click(evt):
    r.move(1)

@bind(document["turn_button"], "click")
def turn_click(evt):
    r.turn_left()

@bind(document["reset_button"], "click")
def reset_click(evt):
    r.reset()
    # ç¨å¾Œé‡æ–°é–‹å§‹è›‡è¡Œ
    timer.set_timeout(snake_patrol, 500)

# è›‡è¡Œèµ°ä½å‡½æ•¸ - å¾(0,0)é–‹å§‹ï¼Œä»¥è›‡è¡Œæ–¹å¼èµ°å®Œæ‰€æœ‰æ ¼å­
def snake_patrol():
    # åˆå§‹ä½ç½® (0,0)ï¼Œé¢å‘æ±
    # è›‡è¡Œç­–ç•¥ï¼šå…ˆå‘å³èµ°åˆ°åº•ï¼Œç„¶å¾Œå‘ä¸Šä¸€æ­¥ï¼Œå†å‘å·¦èµ°åˆ°åº•ï¼Œå†å‘ä¸Šä¸€æ­¥ï¼Œå¦‚æ­¤åè¦†
    
    for row in range(10):  # ç¸½å…±æœ‰10è¡Œ
        if row % 2 == 0:  # å¶æ•¸è¡Œï¼šå¾å·¦åˆ°å³
            # å‘å³ç§»å‹•9æ­¥ï¼ˆå¾æœ€å·¦åˆ°æœ€å³ï¼‰
            r.move(9)
            if row < 9:  # å¦‚æœä¸æ˜¯æœ€å¾Œä¸€è¡Œï¼Œå‘ä¸Šç§»å‹•ä¸¦è½‰å‘
                r.turn_left()   # è½‰å‘åŒ—
                r.move(1)       # å‘ä¸Šä¸€æ­¥
                r.turn_left()   # è½‰å‘è¥¿ï¼ˆæº–å‚™ä¸‹ä¸€è¡Œå‘å·¦èµ°ï¼‰
        else:  # å¥‡æ•¸è¡Œï¼šå¾å³åˆ°å·¦
            # å‘å·¦ç§»å‹•9æ­¥ï¼ˆå¾æœ€å³åˆ°æœ€å·¦ï¼‰
            r.move(9)
            if row < 9:  # å¦‚æœä¸æ˜¯æœ€å¾Œä¸€è¡Œï¼Œå‘ä¸Šç§»å‹•ä¸¦è½‰å‘
                r.turn_right()  # è½‰å‘åŒ—
                r.move(1)       # å‘ä¸Šä¸€æ­¥
                r.turn_right()  # è½‰å‘æ±ï¼ˆæº–å‚™ä¸‹ä¸€è¡Œå‘å³èµ°")

# åŸ·è¡Œè›‡è¡Œèµ°ä½
snake_patrol()
    </script>
</body>
</html>
